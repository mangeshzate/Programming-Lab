#include <iostream>
using namespace std;

#define MAX 50

class Process_details {
public:  // Make members public so roundrobin() can access them
    int pid, arr_time, burst_time, remain_time, waiting_time, turnaround_time;
    bool Ready_Queue;

    Process_details() {
        pid = 0;
        arr_time = 0;
        burst_time = 0;
        remain_time = 0;
        waiting_time = 0;
        turnaround_time = 0;
        Ready_Queue = false;
    }
};

class Circ_Queue {
private:
    int queue[MAX];
    int front, rear;
    int size;

public:
    Circ_Queue() {

        front = -1;
        rear = -1;
        size = 0;
    }

    bool isEmpty() {
        return size == 0;
    }

    void enqueue(int x) {
        if (size == MAX) return;
        if (front == -1) front = 0;  // Initialize front if queue is empty
        rear = (rear + 1) % MAX;
        queue[rear] = x;
        size++;
    }

    int dequeue() {
        if (isEmpty()) return -1;
        int x = queue[front];

        if (front == rear) front = rear = -1;
        else front = (front + 1) % MAX;
        size--;
        return x;
    }
};

void roundrobin(Process_details p[], int n, int quantum) {
    int time = 0;
    int no_proc_completed = 0;
    float avg_WT_time = 0, avg_TA_time = 0;
    Circ_Queue q;

    // Initialize remaining times

    for (int i = 0; i < n; i++) {
        p[i].remain_time = p[i].burst_time;
    }

    // Enqueue all processes that have arrived at time 0

    for (int i = 0; i < n; i++) {
        if (p[i].arr_time <= time && !p[i].Ready_Queue && p[i].remain_time > 0) {
            q.enqueue(i);
            p[i].Ready_Queue = true;
        }
    }

    while (no_proc_completed < n) {
        if (q.isEmpty()) {
            time++;
            // Check if any process has arrived in this time unit

            for (int i = 0; i < n; i++) {
                if (p[i].arr_time <= time && !p[i].Ready_Queue && p[i].remain_time > 0) {
                    q.enqueue(i);
                    p[i].Ready_Queue = true;
                }
            }
            continue;
        }

        int i = q.dequeue();

        if (p[i].remain_time > quantum) {
            time += quantum;
            p[i].remain_time -= quantum;
        } else {
            time += p[i].remain_time;
            p[i].remain_time = 0;
            p[i].turnaround_time = time - p[i].arr_time;
            p[i].waiting_time = p[i].turnaround_time - p[i].burst_time;
            no_proc_completed++;
        }

        // Enqueue any newly arrived processes during this time slice

        for (int j = 0; j < n; j++) {
            if (p[j].arr_time <= time && !p[j].Ready_Queue && p[j].remain_time > 0) {
                q.enqueue(j);
                p[j].Ready_Queue = true;
            }
        }

        // If current process still has remaining time, enqueue it again
        if (p[i].remain_time > 0) {
            q.enqueue(i);
        } else {
            p[i].Ready_Queue = false;
        }
    }

    // Calculate averages

    for (int i = 0; i < n; i++) {
        avg_WT_time += p[i].waiting_time;
        avg_TA_time += p[i].turnaround_time;
    }
    avg_WT_time /= n;
    avg_TA_time /= n;

    // Display process details
    cout << "\nPID\tArrival\tBurst\tWaiting\tTurnaround\n";

    for (int i = 0; i < n; i++) {
        cout << p[i].pid << "\t" << p[i].arr_time << "\t" << p[i].burst_time << "\t"
             << p[i].waiting_time << "\t" << p[i].turnaround_time << "\n";
    }
    cout << "\nAverage Waiting Time: " << avg_WT_time << "\n";
    cout << "Average Turnaround Time: " << avg_TA_time << "\n";
}

int main() {
    int no_of_processes, time_quantum;

    cout << "Enter number of processes: ";
    cin >> no_of_processes;
    cout << "Enter the quantum value: ";
    cin >> time_quantum;

    Process_details p[no_of_processes];

    for (int i = 0; i < no_of_processes; i++) {
        cout << "Enter arrival time and burst time for process " << i + 1 << ": ";
        p[i].pid = i + 1;
        cin >> p[i].arr_time >> p[i].burst_time;
    }

    roundrobin(p, no_of_processes, time_quantum);

    return 0;
}
